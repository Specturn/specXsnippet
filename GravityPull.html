<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Gravity Simulator - Premium Edition</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body,
        html {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            color: white;
            user-select: none;
        }

        #gravityCanvas {
            display: block;
            cursor: crosshair;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* Glassmorphism UI Styles */
        .glass-panel {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        /* Control Bar */
        .control-bar {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 12px 24px;
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            padding: 10px 16px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: translateY(-2px);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }

        .control-btn.active {
            background: rgba(100, 200, 255, 0.3);
            border-color: rgba(100, 200, 255, 0.5);
        }

        /* Speed Slider */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .speed-slider {
            width: 120px;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        .speed-slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #64c8ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        /* Tool Palette */
        .tool-palette {
            position: fixed;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            min-width: 80px;
        }

        .tool-btn {
            width: 60px;
            height: 60px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .tool-btn.active {
            background: rgba(100, 200, 255, 0.4);
            border-color: rgba(100, 200, 255, 0.8);
            box-shadow: 0 0 25px rgba(100, 200, 255, 0.6), inset 0 0 15px rgba(100, 200, 255, 0.2);
            transform: scale(1.05);
        }

        .tool-btn.active::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            background: linear-gradient(45deg, rgba(100, 200, 255, 0.6), rgba(100, 200, 255, 0.3));
            border-radius: 19px;
            z-index: -1;
            animation: activeToolGlow 2s ease-in-out infinite alternate;
        }

        @keyframes activeToolGlow {
            0% {
                opacity: 0.6;
            }

            100% {
                opacity: 1;
            }
        }

        @keyframes feedbackFade {
            0% {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }

            20% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }

            80% {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }

            100% {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
        }

        /* Quick Start Guide */
        .quick-start-guide {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 300;
            padding: 0;
            min-width: 400px;
            max-width: 500px;
            display: block;
        }

        .quick-start-guide.hidden {
            display: none;
        }

        .guide-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .guide-header h3 {
            margin: 0;
            color: #64c8ff;
            font-size: 18px;
        }

        .guide-content {
            padding: 20px;
        }

        .guide-step {
            display: flex;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #64c8ff;
        }

        .step-icon {
            font-size: 24px;
            margin-right: 16px;
            min-width: 32px;
            text-align: center;
        }

        .step-text {
            flex: 1;
            font-size: 14px;
            line-height: 1.4;
        }

        .step-text strong {
            color: #64c8ff;
            display: block;
            margin-bottom: 4px;
        }

        .tool-tooltip {
            position: absolute;
            left: 75px;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        .tool-btn:hover .tool-tooltip {
            opacity: 1;
        }

        /* Properties Inspector */
        .properties-panel {
            position: fixed;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            padding: 20px;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            display: none;
        }

        .properties-panel.visible {
            display: block;
        }

        .property-item {
            margin-bottom: 16px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border-left: 3px solid #64c8ff;
        }

        .property-label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 4px;
        }

        .property-value {
            font-size: 16px;
            font-weight: 600;
            color: #64c8ff;
        }

        /* Mass Slider (for Sun placement) */
        .mass-slider-panel {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            padding: 20px;
            display: none;
        }

        .mass-slider-panel.visible {
            display: block;
        }

        .mass-slider {
            width: 200px;
            margin: 10px 0;
        }

        /* Info Panel */
        .info-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            padding: 20px;
            max-width: 350px;
            display: none;
        }

        .info-panel.visible {
            display: block;
        }

        .info-content {
            font-size: 14px;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
        }

        .info-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
            color: #64c8ff;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .tool-palette {
                left: 10px;
                transform: translateY(-50%) scale(0.9);
            }

            .properties-panel {
                right: 10px;
                min-width: 200px;
                transform: translateY(-50%) scale(0.9);
            }

            .control-bar {
                top: 10px;
                padding: 8px 16px;
                transform: translateX(-50%) scale(0.9);
            }
        }

        /* Loading Animation */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s ease;
        }

        .loading-content {
            text-align: center;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #64c8ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .loading-text {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Settings Panel */
        .settings-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            padding: 0;
            min-width: 400px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }

        .settings-panel.visible {
            display: block;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }

        .close-btn {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
            border-radius: 4px;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }

        .settings-content {
            padding: 20px;
        }

        .setting-group {
            margin-bottom: 24px;
        }

        .setting-group h4 {
            color: #64c8ff;
            margin-bottom: 12px;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .setting-item {
            margin-bottom: 16px;
        }

        .setting-label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.9);
        }

        .setting-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #64c8ff;
        }

        .setting-slider {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            outline: none;
            margin: 8px 0;
        }

        .setting-slider::-webkit-slider-thumb {
            appearance: none;
            width: 18px;
            height: 18px;
            background: #64c8ff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .setting-description {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-top: 4px;
            margin-left: 28px;
        }

        /* Settings Overlay */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 150;
            display: none;
        }

        .settings-overlay.visible {
            display: block;
        }
    </style>
</head>

<body>
    <!-- Loading Screen -->
    <div id="loadingScreen" class="loading-screen">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div class="loading-text">Initializing Gravity Simulator...</div>
        </div>
    </div>

    <!-- Main Canvas -->
    <canvas id="gravityCanvas"></canvas>

    <!-- Control Bar -->
    <div class="control-bar glass-panel">
        <button id="playPauseBtn" class="control-btn">
            <span id="playPauseIcon">⏸️</span>
            <span id="playPauseText">Pause</span>
        </button>

        <div class="speed-control">
            <span style="font-size: 12px;">🐌</span>
            <input type="range" id="speedSlider" class="speed-slider" min="0.1" max="3" step="0.1" value="1">
            <span style="font-size: 12px;">🚀</span>
        </div>

        <button id="resetBtn" class="control-btn">
            <span>🔄</span>
            <span>Reset</span>
        </button>

        <button id="settingsBtn" class="control-btn">
            <span>⚙️</span>
            <span>Settings</span>
        </button>

        <button id="infoToggleBtn" class="control-btn">
            <span>❓</span>
            <span>Info</span>
        </button>
    </div>

    <!-- Tool Palette -->
    <div class="tool-palette glass-panel">
        <div class="tool-btn" id="selectTool" data-tool="select">
            <span>👆</span>
            <div class="tool-tooltip">Select Object</div>
        </div>
        <div class="tool-btn active" id="sunTool" data-tool="sun">
            <span>☀️</span>
            <div class="tool-tooltip">Place Sun</div>
        </div>
        <div class="tool-btn" id="planetTool" data-tool="planet">
            <span>🌎</span>
            <div class="tool-tooltip">Launch Planet</div>
        </div>
        <div class="tool-btn" id="blackHoleTool" data-tool="blackhole">
            <span>⚫</span>
            <div class="tool-tooltip">Create Black Hole</div>
        </div>
        <div class="tool-btn" id="removeTool" data-tool="remove">
            <span>❌</span>
            <div class="tool-tooltip">Remove Object</div>
        </div>
    </div>

    <!-- Properties Inspector -->
    <div id="propertiesPanel" class="properties-panel glass-panel">
        <h3 style="margin-bottom: 16px; color: #64c8ff;">Object Properties</h3>
        <div id="propertiesContent">
            <div class="property-item">
                <div class="property-label">Type</div>
                <div class="property-value" id="objectType">-</div>
            </div>
            <div class="property-item">
                <div class="property-label">Mass</div>
                <div class="property-value" id="objectMass">-</div>
            </div>
            <div class="property-item">
                <div class="property-label">Velocity</div>
                <div class="property-value" id="objectVelocity">-</div>
            </div>
            <div class="property-item">
                <div class="property-label">Gravitational Force</div>
                <div class="property-value" id="objectForce">-</div>
            </div>
        </div>
    </div>

    <!-- Mass Slider Panel -->
    <div id="massSliderPanel" class="mass-slider-panel glass-panel">
        <h4 style="margin-bottom: 10px; color: #64c8ff;">Sun Mass</h4>
        <input type="range" id="massSlider" class="mass-slider" min="500" max="5000" step="100" value="2000">
        <div style="text-align: center; margin-top: 8px;">
            <span id="massValue">2000</span> units
        </div>
        <div style="text-align: center; margin-top: 12px;">
            <button id="placeSunBtn" class="control-btn">Place Sun</button>
            <button id="cancelSunBtn" class="control-btn">Cancel</button>
        </div>
    </div>

    <!-- Info Panel -->
    <div id="infoPanel" class="info-panel glass-panel">
        <div class="info-title" id="infoTitle">Welcome to Gravity Simulator!</div>
        <div class="info-content" id="infoContent">
            Select a tool from the left panel to start creating your cosmic simulation.
            Watch as planets orbit suns, experience realistic physics, and learn about gravity!
        </div>
    </div>

    <!-- Quick Start Guide -->
    <div id="quickStartGuide" class="quick-start-guide glass-panel">
        <div class="guide-header">
            <h3>🚀 Quick Start Guide</h3>
            <button id="closeGuideBtn" class="close-btn">✕</button>
        </div>
        <div class="guide-content">
            <div class="guide-step">
                <span class="step-icon">☀️</span>
                <div class="step-text">
                    <strong>Create Suns:</strong> Click anywhere to place a sun (currently selected)
                </div>
            </div>
            <div class="guide-step">
                <span class="step-icon">🌎</span>
                <div class="step-text">
                    <strong>Launch Planets:</strong> Select planet tool, then drag to set velocity
                </div>
            </div>
            <div class="guide-step">
                <span class="step-icon">⚫</span>
                <div class="step-text">
                    <strong>Black Holes:</strong> Click to create massive gravitational wells
                </div>
            </div>
            <div class="guide-step">
                <span class="step-icon">⏸️</span>
                <div class="step-text">
                    <strong>Controls:</strong> Use the top bar to pause, adjust speed, or reset
                </div>
            </div>
        </div>
    </div>

    <!-- Settings Overlay -->
    <div id="settingsOverlay" class="settings-overlay"></div>

    <!-- Settings Panel -->
    <div id="settingsPanel" class="settings-panel glass-panel"></div>
    <div class="settings-header">
        <h3 style="color: #64c8ff; margin: 0;">Settings</h3>
        <button id="closeSettingsBtn" class="close-btn">✕</button>
    </div>
    <div class="settings-content">
        <div class="setting-group">
            <h4>Performance</h4>
            <div class="setting-item">
                <label class="setting-label">
                    <input type="checkbox" id="performanceModeToggle">
                    <span>Performance Mode</span>
                </label>
                <div class="setting-description">Disable visual effects for better performance</div>
            </div>
        </div>

        <div class="setting-group">
            <h4>Visual Quality</h4>
            <div class="setting-item">
                <label class="setting-label">
                    <input type="checkbox" id="particleEffectsToggle" checked>
                    <span>Particle Effects</span>
                </label>
            </div>
            <div class="setting-item">
                <label class="setting-label">
                    <input type="checkbox" id="trailEffectsToggle" checked>
                    <span>Orbital Trails</span>
                </label>
            </div>
            <div class="setting-item">
                <label class="setting-label">
                    <input type="checkbox" id="coronaEffectsToggle" checked>
                    <span>Solar Corona</span>
                </label>
            </div>
        </div>

        <div class="setting-group">
            <h4>Educational</h4>
            <div class="setting-item">
                <label class="setting-label">
                    <input type="checkbox" id="autoInfoToggle" checked>
                    <span>Auto-Show Info Panel</span>
                </label>
                <div class="setting-description">Automatically display physics explanations</div>
            </div>
        </div>

        <div class="setting-group">
            <h4>Simulation</h4>
            <div class="setting-item">
                <label class="setting-label">Trail Length</label>
                <input type="range" id="trailLengthSlider" min="50" max="300" value="150" class="setting-slider">
                <span id="trailLengthValue">150</span>
            </div>
            <div class="setting-item">
                <label class="setting-label">Max Objects</label>
                <input type="range" id="maxObjectsSlider" min="10" max="100" value="50" class="setting-slider">
                <span id="maxObjectsValue">50</span>
            </div>
        </div>
    </div>
    </div>

    <script>
        // ===== CORE ARCHITECTURE =====

        // Vector2D utility class for mathematical operations
        class Vector2D {
            constructor(x = 0, y = 0) {
                // Ensure finite values to prevent NaN propagation
                this.x = isFinite(x) ? x : 0;
                this.y = isFinite(y) ? y : 0;
            }

            add(vector) {
                if (!vector) return new Vector2D(this.x, this.y);
                return new Vector2D(this.x + (vector.x || 0), this.y + (vector.y || 0));
            }

            subtract(vector) {
                if (!vector) return new Vector2D(this.x, this.y);
                return new Vector2D(this.x - (vector.x || 0), this.y - (vector.y || 0));
            }

            multiply(scalar) {
                const safeScalar = isFinite(scalar) ? scalar : 0;
                return new Vector2D(this.x * safeScalar, this.y * safeScalar);
            }

            magnitude() {
                const squaredMagnitude = this.x * this.x + this.y * this.y;
                return Math.sqrt(Math.max(0, squaredMagnitude));
            }

            normalize() {
                const mag = this.magnitude();
                return mag > 0 ? new Vector2D(this.x / mag, this.y / mag) : new Vector2D(0, 0);
            }

            distance(vector) {
                return this.subtract(vector).magnitude();
            }
        }

        // Abstract base class for celestial bodies
        class CelestialBody {
            constructor(x, y, mass = 1000) {
                // Validate and sanitize input parameters
                const safeX = isFinite(x) ? x : 0;
                const safeY = isFinite(y) ? y : 0;
                const safeMass = isFinite(mass) && mass > 0 ? mass : 1000;

                this.position = new Vector2D(safeX, safeY);
                this.velocity = new Vector2D(0, 0);
                this.mass = safeMass;
                this.radius = this.calculateRadius();
                this.id = Math.random().toString(36).substr(2, 9);
                this.selected = false;
            }

            calculateRadius() {
                const safeMass = isFinite(this.mass) && this.mass > 0 ? this.mass : 100;
                const radius = Math.sqrt(safeMass / 100);
                return Math.max(5, isFinite(radius) ? radius : 5);
            }

            update(deltaTime, objects) {
                // To be implemented by subclasses
            }

            render(ctx) {
                // To be implemented by subclasses
            }

            getGravitationalForce(other) {
                // Validate input object
                if (!other || !other.position || !isFinite(other.mass)) {
                    return new Vector2D(0, 0);
                }

                const direction = other.position.subtract(this.position);
                const rawDistance = direction.magnitude();

                // Ensure minimum distance to prevent division by zero and extreme forces
                const minDistance = Math.max(this.radius + other.radius, 1);
                const distance = Math.max(rawDistance, minDistance);

                // Validate masses to prevent NaN
                const mass1 = isFinite(this.mass) && this.mass > 0 ? this.mass : 1;
                const mass2 = isFinite(other.mass) && other.mass > 0 ? other.mass : 1;

                // Calculate force with safety checks
                const distanceSquared = distance * distance;
                if (distanceSquared === 0) {
                    return new Vector2D(0, 0);
                }

                const forceMagnitude = (mass1 * mass2) / distanceSquared * 0.1;

                // Validate force magnitude
                if (!isFinite(forceMagnitude)) {
                    return new Vector2D(0, 0);
                }

                const normalizedDirection = direction.normalize();
                return normalizedDirection.multiply(forceMagnitude);
            }

            isPointInside(x, y) {
                const distance = this.position.distance(new Vector2D(x, y));
                return distance <= this.radius;
            }
        }

        // Sun class with enhanced visuals
        class Sun extends CelestialBody {
            constructor(x, y, mass = 2000) {
                super(x, y, mass);
                this.type = 'sun';
                this.temperature = 5778; // Kelvin
                this.coronaRadius = this.radius * 1.5;
                this.flareParticles = [];
            }

            calculateRadius() {
                const safeMass = isFinite(this.mass) && this.mass > 0 ? this.mass : 2000;
                const radius = Math.sqrt(safeMass / 50);
                return Math.max(15, isFinite(radius) ? radius : 15);
            }

            update(deltaTime, objects) {
                this.coronaRadius = this.radius * 1.5;

                // Generate solar flares occasionally
                if (Math.random() < 0.02) {
                    this.generateSolarFlare();
                }

                // Update flare particles
                this.flareParticles = this.flareParticles.filter(particle => {
                    particle.life -= deltaTime;
                    particle.position = particle.position.add(particle.velocity.multiply(deltaTime));
                    return particle.life > 0;
                });
            }

            generateSolarFlare() {
                const angle = Math.random() * Math.PI * 2;
                const velocity = new Vector2D(
                    Math.cos(angle) * (20 + Math.random() * 30),
                    Math.sin(angle) * (20 + Math.random() * 30)
                );

                this.flareParticles.push({
                    position: this.position.add(new Vector2D(
                        Math.cos(angle) * this.radius,
                        Math.sin(angle) * this.radius
                    )),
                    velocity: velocity,
                    life: 0.5 + Math.random() * 0.5,
                    maxLife: 1.0,
                    size: 2 + Math.random() * 3
                });
            }

            render(ctx, settings = {}) {
                // Draw corona (glow effect) - respect corona effects setting
                if (settings.coronaEffects !== false) {
                    const gradient = ctx.createRadialGradient(
                        this.position.x, this.position.y, this.radius * 0.5,
                        this.position.x, this.position.y, this.coronaRadius
                    );
                    gradient.addColorStop(0, 'rgba(255, 215, 0, 0.8)');
                    gradient.addColorStop(0.7, 'rgba(255, 140, 0, 0.4)');
                    gradient.addColorStop(1, 'rgba(255, 69, 0, 0.1)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.coronaRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Draw main sun body
                const sunGradient = ctx.createRadialGradient(
                    this.position.x - this.radius * 0.3, this.position.y - this.radius * 0.3, 0,
                    this.position.x, this.position.y, this.radius
                );
                sunGradient.addColorStop(0, '#FFF8DC');
                sunGradient.addColorStop(0.5, '#FFD700');
                sunGradient.addColorStop(1, '#FF8C00');

                ctx.fillStyle = sunGradient;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw solar flares - respect particle effects setting
                if (settings.particleEffects !== false) {
                    this.flareParticles.forEach(particle => {
                        const maxLife = isFinite(particle.maxLife) && particle.maxLife > 0 ? particle.maxLife : 1;
                        const alpha = Math.max(0, Math.min(1, particle.life / maxLife));
                        ctx.fillStyle = `rgba(255, 100, 0, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(particle.position.x, particle.position.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    });
                }

                // Draw selection indicator
                if (this.selected) {
                    ctx.strokeStyle = '#64c8ff';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.radius + 10, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        // Planet class with trails and enhanced physics
        class Planet extends CelestialBody {
            constructor(x, y, vx = 0, vy = 0, mass = 100) {
                super(x, y, mass);
                this.type = 'planet';

                // Validate velocity parameters
                const safeVx = isFinite(vx) ? vx : 0;
                const safeVy = isFinite(vy) ? vy : 0;

                this.velocity = new Vector2D(safeVx, safeVy);
                this.trail = [];
                this.maxTrailLength = 150;
                this.planetType = Math.random() > 0.5 ? 'terrestrial' : 'gasGiant';
                this.color = this.generateColor();
            }

            generateColor() {
                const colors = {
                    terrestrial: ['#8B4513', '#CD853F', '#A0522D', '#D2691E'],
                    gasGiant: ['#4169E1', '#6495ED', '#87CEEB', '#B0C4DE']
                };
                const colorSet = colors[this.planetType];
                return colorSet[Math.floor(Math.random() * colorSet.length)];
            }

            update(deltaTime, objects) {
                // Apply gravitational forces from all Suns and BlackHoles
                let totalAcceleration = new Vector2D(0, 0);

                // Loop through all objects to find gravitational sources
                objects.forEach(other => {
                    if (other !== this && (other instanceof Sun || other instanceof BlackHole)) {
                        // Calculate distance vector (from planet to gravitational source)
                        const dx = other.position.x - this.position.x;
                        const dy = other.position.y - this.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        // Prevent division by zero - minimum distance constraint
                        const minDistance = Math.max(this.radius + other.radius, 5);
                        const safeDistance = Math.max(distance, minDistance);

                        // Calculate gravitational force magnitude using Newton's law
                        // F = G * m1 * m2 / r^2, but we simplify G and use mass ratios
                        // Increased gravitational constant for more visible effects
                        const forceMagnitude = (other.mass * 200) / (safeDistance * safeDistance);

                        // Calculate acceleration components (F = ma, so a = F/m)
                        // Direction: normalized vector pointing towards the gravitational source
                        const ax = (dx / safeDistance) * forceMagnitude / this.mass;
                        const ay = (dy / safeDistance) * forceMagnitude / this.mass;

                        // Accumulate acceleration from all sources
                        totalAcceleration.x += ax;
                        totalAcceleration.y += ay;

                        // Store the strongest gravitational influence for visual feedback
                        if (!this.strongestAttractor || forceMagnitude > this.strongestForce) {
                            this.strongestAttractor = other;
                            this.strongestForce = forceMagnitude;
                        }
                    }
                });

                // Reset strongest attractor tracking for next frame
                this.strongestAttractor = null;
                this.strongestForce = 0;

                // Update velocity by adding acceleration (v = v + a*dt)
                this.velocity.x += totalAcceleration.x * deltaTime;
                this.velocity.y += totalAcceleration.y * deltaTime;

                // Update position by adding velocity (p = p + v*dt)
                this.position.x += this.velocity.x * deltaTime;
                this.position.y += this.velocity.y * deltaTime;

                // Update trail
                this.trail.push({
                    x: this.position.x,
                    y: this.position.y,
                    alpha: 1.0
                });

                if (this.trail.length > this.maxTrailLength) {
                    this.trail.shift();
                }

                // Fade trail with safety checks
                const trailLength = this.trail.length || 1; // Prevent division by zero
                this.trail.forEach((point, index) => {
                    point.alpha = Math.max(0, Math.min(1, index / trailLength));
                });
            }

            render(ctx, settings = {}) {
                // Draw trail - respect trail effects setting
                if (settings.trailEffects !== false && this.trail.length > 1) {
                    ctx.lineWidth = 2;
                    for (let i = 1; i < this.trail.length; i++) {
                        const alpha = this.trail[i].alpha * 0.7;
                        ctx.strokeStyle = `rgba(100, 200, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.moveTo(this.trail[i - 1].x, this.trail[i - 1].y);
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                        ctx.stroke();
                    }
                }

                // Draw planet with gradient
                const gradient = ctx.createRadialGradient(
                    this.position.x - this.radius * 0.3, this.position.y - this.radius * 0.3, 0,
                    this.position.x, this.position.y, this.radius
                );

                const baseColor = this.color;
                gradient.addColorStop(0, this.lightenColor(baseColor, 40));
                gradient.addColorStop(0.7, baseColor);
                gradient.addColorStop(1, this.darkenColor(baseColor, 30));

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Add subtle atmosphere for gas giants
                if (this.planetType === 'gasGiant') {
                    ctx.strokeStyle = `rgba(100, 150, 255, 0.3)`;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.radius + 2, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw selection indicator
                if (this.selected) {
                    ctx.strokeStyle = '#64c8ff';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([3, 3]);
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.radius + 8, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            lightenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return "#" + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                    (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 + (B < 255 ? B < 1 ? 0 : B : 255)).toString(16).slice(1);
            }

            darkenColor(color, percent) {
                const num = parseInt(color.replace("#", ""), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return "#" + (0x1000000 + (R > 255 ? 255 : R < 0 ? 0 : R) * 0x10000 +
                    (G > 255 ? 255 : G < 0 ? 0 : G) * 0x100 + (B > 255 ? 255 : B < 0 ? 0 : B)).toString(16).slice(1);
            }
        }

        // BlackHole class with event horizon
        class BlackHole extends CelestialBody {
            constructor(x, y, mass = 5000) {
                super(x, y, mass);
                this.type = 'blackhole';
                this.eventHorizon = this.radius * 2;
                this.accretionDisk = [];
            }

            calculateRadius() {
                const safeMass = isFinite(this.mass) && this.mass > 0 ? this.mass : 5000;
                const radius = Math.sqrt(safeMass / 200);
                return Math.max(10, isFinite(radius) ? radius : 10);
            }

            update(deltaTime, objects) {
                this.eventHorizon = this.radius * 2.5;

                // Check for objects crossing event horizon
                objects.forEach(obj => {
                    if (obj !== this && obj instanceof Planet) {
                        const distance = this.position.distance(obj.position);
                        if (distance <= this.eventHorizon) {
                            // Mark for removal (will be handled by simulation engine)
                            obj.markedForRemoval = true;
                        }
                    }
                });
            }

            render(ctx, settings = {}) {
                // Draw event horizon
                ctx.fillStyle = 'rgba(50, 0, 100, 0.3)';
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.eventHorizon, 0, Math.PI * 2);
                ctx.fill();

                // Draw accretion disk - respect particle effects setting
                if (settings.particleEffects !== false) {
                    ctx.strokeStyle = 'rgba(255, 100, 0, 0.6)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.eventHorizon * 0.8, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw black hole (very dark center)
                const gradient = ctx.createRadialGradient(
                    this.position.x, this.position.y, 0,
                    this.position.x, this.position.y, this.radius
                );
                gradient.addColorStop(0, '#000000');
                gradient.addColorStop(0.8, '#1a0033');
                gradient.addColorStop(1, '#330066');

                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Draw selection indicator
                if (this.selected) {
                    ctx.strokeStyle = '#64c8ff';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, this.eventHorizon + 5, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }

        // Particle System for Visual Effects
        class ParticleSystem {
            constructor() {
                this.particles = [];
            }

            createCollisionBurst(position, intensity = 1.0) {
                const particleCount = Math.floor(15 * intensity);
                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount + Math.random() * 0.5;
                    const speed = 50 + Math.random() * 100 * intensity;
                    const velocity = new Vector2D(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed
                    );

                    this.particles.push({
                        position: new Vector2D(position.x, position.y),
                        velocity: velocity,
                        life: 0.8 + Math.random() * 0.4,
                        maxLife: 1.2,
                        size: 2 + Math.random() * 4,
                        color: `hsl(${30 + Math.random() * 60}, 100%, ${50 + Math.random() * 30}%)`,
                        alpha: 1.0
                    });
                }
            }

            createSolarFlare(sun, impactPoint) {
                const particleCount = 25;
                const direction = impactPoint.subtract(sun.position).normalize();

                for (let i = 0; i < particleCount; i++) {
                    const spread = 0.8;
                    const angle = Math.atan2(direction.y, direction.x) + (Math.random() - 0.5) * spread;
                    const speed = 80 + Math.random() * 120;
                    const velocity = new Vector2D(
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed
                    );

                    this.particles.push({
                        position: new Vector2D(impactPoint.x, impactPoint.y),
                        velocity: velocity,
                        life: 1.0 + Math.random() * 0.8,
                        maxLife: 1.8,
                        size: 3 + Math.random() * 6,
                        color: `hsl(${Math.random() * 60}, 100%, ${70 + Math.random() * 20}%)`,
                        alpha: 1.0,
                        type: 'flare'
                    });
                }
            }

            update(deltaTime) {
                this.particles = this.particles.filter(particle => {
                    particle.life -= deltaTime;
                    particle.position = particle.position.add(particle.velocity.multiply(deltaTime));

                    // Calculate alpha with safety checks
                    const maxLife = isFinite(particle.maxLife) && particle.maxLife > 0 ? particle.maxLife : 1;
                    particle.alpha = Math.max(0, Math.min(1, particle.life / maxLife));

                    // Apply gravity for flare particles
                    if (particle.type === 'flare') {
                        particle.velocity = particle.velocity.multiply(0.98); // Slight deceleration
                    }

                    return particle.life > 0;
                });
            }

            render(ctx, settings) {
                if (!settings.particleEffects) return;

                this.particles.forEach(particle => {
                    ctx.save();
                    ctx.globalAlpha = particle.alpha;
                    ctx.fillStyle = particle.color;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.position.x, particle.position.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                });
            }
        }

        // Collision System for Realistic Physics
        class CollisionSystem {
            constructor() {
                this.collisionPairs = new Set();
            }

            detectCollisions(objects) {
                const collisions = [];

                for (let i = 0; i < objects.length; i++) {
                    for (let j = i + 1; j < objects.length; j++) {
                        const obj1 = objects[i];
                        const obj2 = objects[j];

                        const distance = obj1.position.distance(obj2.position);
                        const minDistance = obj1.radius + obj2.radius;

                        if (distance <= minDistance) {
                            const pairKey = `${Math.min(obj1.id, obj2.id)}-${Math.max(obj1.id, obj2.id)}`;

                            // Prevent duplicate collision processing
                            if (!this.collisionPairs.has(pairKey)) {
                                this.collisionPairs.add(pairKey);
                                collisions.push({
                                    obj1: obj1,
                                    obj2: obj2,
                                    distance: distance,
                                    overlap: minDistance - distance,
                                    pairKey: pairKey
                                });
                            }
                        } else {
                            // Remove from collision pairs if objects are no longer colliding
                            const pairKey = `${Math.min(obj1.id, obj2.id)}-${Math.max(obj1.id, obj2.id)}`;
                            this.collisionPairs.delete(pairKey);
                        }
                    }
                }

                return collisions;
            }

            resolveCollision(collision, particleSystem) {
                const { obj1, obj2, overlap } = collision;

                // Determine collision type and handle accordingly
                if (obj1 instanceof Sun && obj2 instanceof Planet) {
                    return this.handleSunPlanetCollision(obj1, obj2, particleSystem);
                } else if (obj1 instanceof Planet && obj2 instanceof Sun) {
                    return this.handleSunPlanetCollision(obj2, obj1, particleSystem);
                } else if (obj1 instanceof BlackHole || obj2 instanceof BlackHole) {
                    return this.handleBlackHoleCollision(obj1, obj2);
                } else if (obj1 instanceof Planet && obj2 instanceof Planet) {
                    return this.handlePlanetPlanetCollision(obj1, obj2, overlap, particleSystem);
                }

                return { removeObjects: [] };
            }

            handleSunPlanetCollision(sun, planet, particleSystem) {
                // Create dramatic solar flare effect
                particleSystem.createSolarFlare(sun, planet.position);

                // Planet is absorbed by the sun
                return { removeObjects: [planet] };
            }

            handleBlackHoleCollision(obj1, obj2) {
                const blackHole = obj1 instanceof BlackHole ? obj1 : obj2;
                const other = obj1 instanceof BlackHole ? obj2 : obj1;

                // Object is consumed by black hole
                return { removeObjects: [other] };
            }

            handlePlanetPlanetCollision(planet1, planet2, overlap, particleSystem) {
                // Separate overlapping objects
                const collisionNormal = planet2.position.subtract(planet1.position).normalize();
                const separationDistance = overlap / 2;

                planet1.position = planet1.position.subtract(collisionNormal.multiply(separationDistance));
                planet2.position = planet2.position.add(collisionNormal.multiply(separationDistance));

                // Calculate collision point for particle effect
                const collisionPoint = planet1.position.add(
                    collisionNormal.multiply(planet1.radius)
                );

                // Create collision particle burst
                const intensity = Math.min(2.0, (planet1.velocity.magnitude() + planet2.velocity.magnitude()) / 100);
                particleSystem.createCollisionBurst(collisionPoint, intensity);

                // Elastic collision physics
                this.calculateElasticCollision(planet1, planet2, collisionNormal);

                // Play collision sound (if audio context is available)
                this.playCollisionSound(intensity);

                return { removeObjects: [] };
            }

            calculateElasticCollision(obj1, obj2, normal) {
                // Relative velocity in collision normal direction
                const relativeVelocity = obj1.velocity.subtract(obj2.velocity);
                const velocityInNormal = relativeVelocity.x * normal.x + relativeVelocity.y * normal.y;

                // Do not resolve if velocities are separating
                if (velocityInNormal > 0) return;

                // Restitution coefficient (bounciness)
                const restitution = 0.8;

                // Validate masses to prevent division by zero
                const mass1 = isFinite(obj1.mass) && obj1.mass > 0 ? obj1.mass : 1;
                const mass2 = isFinite(obj2.mass) && obj2.mass > 0 ? obj2.mass : 1;

                // Calculate impulse scalar with safety checks
                const massSum = (1 / mass1) + (1 / mass2);
                if (massSum === 0 || !isFinite(massSum)) {
                    return; // Skip collision if masses are invalid
                }

                const impulse = -(1 + restitution) * velocityInNormal / massSum;

                // Validate impulse
                if (!isFinite(impulse)) {
                    return; // Skip collision if impulse is invalid
                }

                // Apply impulse to velocities
                const impulseVector = normal.multiply(impulse);

                obj1.velocity = obj1.velocity.add(impulseVector.multiply(1 / mass1));
                obj2.velocity = obj2.velocity.subtract(impulseVector.multiply(1 / mass2));

                // Add some energy loss for realism
                obj1.velocity = obj1.velocity.multiply(0.98);
                obj2.velocity = obj2.velocity.multiply(0.98);
            }

            playCollisionSound(intensity) {
                // Create a simple collision sound using Web Audio API
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    // Low frequency thump
                    oscillator.frequency.setValueAtTime(60 + intensity * 40, audioContext.currentTime);
                    oscillator.type = 'sine';

                    // Volume based on collision intensity
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(Math.min(0.1, intensity * 0.05), audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                } catch (e) {
                    // Audio not supported or blocked
                }
            }
        }

        // Enhanced Background Renderer with Dynamic Nebula
        class BackgroundRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.nebulaOffset = { x: 0, y: 0 };
                this.starField = this.generateStarField();
                this.nebulaLayers = this.generateNebulaLayers();
            }

            generateStarField() {
                const stars = [];
                for (let i = 0; i < 200; i++) {
                    stars.push({
                        x: Math.random() * this.canvas.width * 2,
                        y: Math.random() * this.canvas.height * 2,
                        size: Math.random() * 2 + 0.5,
                        brightness: Math.random() * 0.8 + 0.2,
                        twinkle: Math.random() * Math.PI * 2,
                        layer: Math.random() * 3 // Different parallax layers
                    });
                }
                return stars;
            }

            generateNebulaLayers() {
                return [
                    {
                        color: 'rgba(138, 43, 226, 0.1)',
                        speed: 0.2,
                        scale: 1.5
                    },
                    {
                        color: 'rgba(75, 0, 130, 0.08)',
                        speed: 0.15,
                        scale: 2.0
                    },
                    {
                        color: 'rgba(25, 25, 112, 0.05)',
                        speed: 0.1,
                        scale: 2.5
                    }
                ];
            }

            update(deltaTime) {
                // Validate deltaTime to prevent infinite accumulation
                const safeDeltaTime = this.validateFiniteNumber(deltaTime, 0);

                // Prevent deltaTime from being too large (cap at 1 second)
                const cappedDeltaTime = Math.min(Math.abs(safeDeltaTime), 1.0);

                // Slowly drift the nebula with bounds checking
                this.nebulaOffset.x += cappedDeltaTime * 5;
                this.nebulaOffset.y += cappedDeltaTime * 3;

                // Prevent offset values from growing too large (reset when they exceed reasonable bounds)
                const maxOffset = 100000; // Reasonable maximum to prevent overflow
                if (Math.abs(this.nebulaOffset.x) > maxOffset) {
                    this.nebulaOffset.x = this.nebulaOffset.x % maxOffset;
                }
                if (Math.abs(this.nebulaOffset.y) > maxOffset) {
                    this.nebulaOffset.y = this.nebulaOffset.y % maxOffset;
                }

                // Final safety check - ensure offsets remain finite
                this.nebulaOffset.x = this.validateFiniteNumber(this.nebulaOffset.x, 0);
                this.nebulaOffset.y = this.validateFiniteNumber(this.nebulaOffset.y, 0);

                // Update star twinkle with validated deltaTime
                this.starField.forEach(star => {
                    star.twinkle += cappedDeltaTime * 2;
                });
            }

            render(ctx, settings) {
                try {
                    // Validate canvas dimensions
                    const canvasWidth = this.validateFiniteNumber(this.canvas.width, 800);
                    const canvasHeight = this.validateFiniteNumber(this.canvas.height, 600);

                    // Base gradient background with safety checks
                    const centerX = canvasWidth / 2;
                    const centerY = canvasHeight / 2;
                    const maxRadius = Math.max(canvasWidth, canvasHeight);

                    // Validate gradient parameters before creating
                    const gradientParams = this.validateGradientParams(centerX, centerY, 0, maxRadius);

                    const gradient = ctx.createRadialGradient(
                        gradientParams.x, gradientParams.y, gradientParams.radius1,
                        gradientParams.x, gradientParams.y, gradientParams.radius2
                    );
                    gradient.addColorStop(0, '#1a1a2e');
                    gradient.addColorStop(0.5, '#16213e');
                    gradient.addColorStop(1, '#0f0f23');

                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                    if (!settings.performanceMode) {
                        // Render nebula layers with parallax
                        this.renderNebulaLayers(ctx);
                    }

                    // Render stars with parallax and twinkling
                    this.renderStarField(ctx, settings);
                } catch (renderError) {
                    console.error('BackgroundRenderer error (non-critical):', renderError);
                    // Fallback: render simple gradient background
                    try {
                        const fallbackGradient = ctx.createRadialGradient(
                            400, 300, 0, 400, 300, 500
                        );
                        fallbackGradient.addColorStop(0, '#1a1a2e');
                        fallbackGradient.addColorStop(1, '#0f0f23');
                        ctx.fillStyle = fallbackGradient;
                        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    } catch (fallbackError) {
                        // Ultimate fallback: solid color
                        ctx.fillStyle = '#1a1a2e';
                        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                    }
                }
            }

            renderNebulaLayers(ctx) {
                this.nebulaLayers.forEach((layer, index) => {
                    ctx.save();
                    ctx.globalAlpha = 0.6;

                    const offsetX = this.nebulaOffset.x * layer.speed;
                    const offsetY = this.nebulaOffset.y * layer.speed;

                    // Create nebula clouds using gradients with comprehensive input validation
                    for (let i = 0; i < 3; i++) {
                        try {
                            // Calculate raw values with safety checks for modulo operations
                            const canvasWidth = this.canvas.width || 800;
                            const canvasHeight = this.canvas.height || 600;

                            const rawX = (offsetX + i * 400) % (canvasWidth + 200) - 100;
                            const rawY = (offsetY + i * 300) % (canvasHeight + 200) - 100;
                            const rawRadius = 150 * (layer.scale || 1);

                            // Use comprehensive gradient parameter validation
                            const gradientParams = this.validateGradientParams(rawX, rawY, 0, rawRadius);

                            // Final safety check - ensure all parameters are valid for createRadialGradient
                            if (!isFinite(gradientParams.x) || !isFinite(gradientParams.y) ||
                                !isFinite(gradientParams.radius1) || !isFinite(gradientParams.radius2) ||
                                gradientParams.radius2 <= 0) {
                                console.warn(`Skipping nebula gradient due to invalid parameters:`, gradientParams);
                                continue;
                            }

                            const nebulaGradient = ctx.createRadialGradient(
                                gradientParams.x, gradientParams.y, gradientParams.radius1,
                                gradientParams.x, gradientParams.y, gradientParams.radius2
                            );
                            nebulaGradient.addColorStop(0, layer.color);
                            nebulaGradient.addColorStop(1, 'transparent');

                            ctx.fillStyle = nebulaGradient;
                            ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                        } catch (gradientError) {
                            console.warn('Error creating nebula gradient (non-critical):', gradientError);
                            // Continue with next iteration instead of crashing
                        }
                    }

                    ctx.restore();
                });
            }

            renderStarField(ctx, settings) {
                this.starField.forEach(star => {
                    try {
                        // Validate star properties
                        const safeLayer = this.validateFiniteNumber(star.layer, 0);
                        const parallaxFactor = 1 - safeLayer * 0.3;

                        // Calculate positions with safety checks
                        const canvasWidth = this.canvas.width || 800;
                        const canvasHeight = this.canvas.height || 600;

                        const rawX = (star.x - this.nebulaOffset.x * parallaxFactor * 0.1);
                        const rawY = (star.y - this.nebulaOffset.y * parallaxFactor * 0.1);

                        const x = this.validateFiniteNumber(rawX % (canvasWidth + 100), 0);
                        const y = this.validateFiniteNumber(rawY % (canvasHeight + 100), 0);

                        // Skip if position is invalid or out of reasonable bounds
                        if (!isFinite(x) || !isFinite(y) ||
                            x < -50 || x > canvasWidth + 50 ||
                            y < -50 || y > canvasHeight + 50) {
                            return;
                        }

                        let alpha = this.validateFiniteNumber(star.brightness, 0.5);
                        if (!settings.performanceMode) {
                            const twinkleValue = this.validateFiniteNumber(star.twinkle, 0);
                            alpha *= (Math.sin(twinkleValue) * 0.3 + 0.7);
                        }

                        // Clamp alpha to valid range
                        alpha = Math.max(0, Math.min(1, alpha));

                        const starSize = this.validateFiniteNumber(star.size, 1);

                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                        ctx.beginPath();
                        ctx.arc(x, y, starSize, 0, Math.PI * 2);
                        ctx.fill();
                    } catch (starError) {
                        console.warn('Error rendering star (non-critical):', starError);
                        // Continue with next star instead of crashing
                    }
                });
            }

            // Utility method to validate and sanitize finite numbers
            validateFiniteNumber(value, fallback = 0) {
                if (typeof value !== 'number' || !isFinite(value) || isNaN(value)) {
                    return fallback;
                }
                return value;
            }

            // Additional safety method for gradient parameters
            validateGradientParams(x, y, radius1, radius2) {
                const safeX = this.validateFiniteNumber(x, 0);
                const safeY = this.validateFiniteNumber(y, 0);
                const safeRadius1 = this.validateFiniteNumber(radius1, 0);
                const safeRadius2 = this.validateFiniteNumber(radius2, Math.max(safeRadius1 + 1, 1));

                // Ensure radius2 is always greater than radius1 for valid gradient
                if (safeRadius2 <= safeRadius1) {
                    return {
                        x: safeX,
                        y: safeY,
                        radius1: safeRadius1,
                        radius2: safeRadius1 + 1
                    };
                }

                return {
                    x: safeX,
                    y: safeY,
                    radius1: safeRadius1,
                    radius2: safeRadius2
                };
            }
        }

        // Main Simulation Engine
        class SimulationEngine {
            constructor(canvas) {
                try {
                    if (!canvas) {
                        throw new Error('Canvas element is required');
                    }

                    this.canvas = canvas;
                    this.ctx = canvas.getContext('2d');

                    if (!this.ctx) {
                        throw new Error('Could not get 2D context from canvas');
                    }

                    this.objects = [];
                    this.selectedObject = null;
                    this.isRunning = true;
                    this.speed = 1.0;
                    this.lastTime = 0;
                    this.maxObjects = 50;
                    this.performanceMode = false;
                    this.settings = {
                        particleEffects: true,
                        trailEffects: true,
                        coronaEffects: true,
                        performanceMode: false
                    };

                    // Initialize new systems with error handling
                    try {
                        this.collisionSystem = new CollisionSystem();
                        this.particleSystem = new ParticleSystem();
                        this.backgroundRenderer = new BackgroundRenderer(canvas);
                    } catch (systemError) {
                        console.error('Error initializing simulation systems:', systemError);
                        throw new Error('Failed to initialize simulation systems');
                    }

                    this.setupCanvas();
                    this.setupEventListeners();

                    console.log('SimulationEngine initialized successfully');
                } catch (error) {
                    console.error('SimulationEngine constructor error:', error);
                    throw error;
                }
            }

            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupEventListeners() {
                // Canvas event listeners will be handled by ToolManager
            }

            addObject(object) {
                if (this.objects.length < this.maxObjects) {
                    this.objects.push(object);
                    return true;
                }
                return false;
            }

            removeObject(object) {
                const index = this.objects.indexOf(object);
                if (index > -1) {
                    this.objects.splice(index, 1);
                }
                if (this.selectedObject === object) {
                    this.selectedObject = null;
                }
            }

            selectObject(object) {
                // Deselect previous object
                if (this.selectedObject) {
                    this.selectedObject.selected = false;
                }

                // Select new object
                this.selectedObject = object;
                if (object) {
                    object.selected = true;
                }
            }

            update(deltaTime) {
                try {
                    if (!this.isRunning) return;

                    const adjustedDeltaTime = deltaTime * this.speed;



                    // Update background animation with error handling
                    try {
                        if (this.backgroundRenderer && this.backgroundRenderer.update) {
                            this.backgroundRenderer.update(adjustedDeltaTime);
                        }
                    } catch (error) {
                        console.warn('Background update error (non-critical):', error);
                    }

                    // Update all objects with error handling
                    try {
                        this.objects.forEach((obj) => {
                            if (obj && obj.update) {
                                obj.update(adjustedDeltaTime, this.objects);
                            }
                        });
                    } catch (error) {
                        console.warn('Object update error:', error);
                    }

                    // Detect and resolve collisions with error handling
                    try {
                        if (this.collisionSystem && this.collisionSystem.detectCollisions) {
                            const collisions = this.collisionSystem.detectCollisions(this.objects);
                            const objectsToRemove = [];

                            collisions.forEach(collision => {
                                try {
                                    const result = this.collisionSystem.resolveCollision(collision, this.particleSystem);
                                    objectsToRemove.push(...result.removeObjects);
                                } catch (collisionError) {
                                    console.warn('Collision resolution error:', collisionError);
                                }
                            });

                            // Remove objects from collisions
                            objectsToRemove.forEach(obj => {
                                this.removeObject(obj);
                            });
                        }
                    } catch (error) {
                        console.warn('Collision system error:', error);
                    }

                    // Update particle system with error handling
                    try {
                        if (this.particleSystem && this.particleSystem.update) {
                            this.particleSystem.update(adjustedDeltaTime);
                        }
                    } catch (error) {
                        console.warn('Particle system update error (non-critical):', error);
                    }

                    // Remove objects marked for removal (black holes, etc.)
                    try {
                        this.objects = this.objects.filter(obj => !obj.markedForRemoval);
                    } catch (error) {
                        console.warn('Object removal filter error:', error);
                    }

                    // Remove objects that are too far off screen
                    try {
                        this.objects = this.objects.filter(obj => {
                            const margin = 500;
                            return obj.position &&
                                obj.position.x > -margin && obj.position.x < this.canvas.width + margin &&
                                obj.position.y > -margin && obj.position.y < this.canvas.height + margin;
                        });
                    } catch (error) {
                        console.warn('Off-screen object removal error:', error);
                    }
                } catch (error) {
                    console.error('Critical update error:', error);
                    // Don't throw - let the animation loop handle recovery
                }
            }

            render() {
                // Clear canvas first
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // Render dynamic background with nebula
                this.backgroundRenderer.render(this.ctx, this.settings);

                // Render all celestial objects
                // Render all celestial objects
                this.objects.forEach((obj) => {
                    if (obj && obj.render) {
                        obj.render(this.ctx, this.settings);
                    }
                });

                // Render particle effects
                try {
                    this.particleSystem.render(this.ctx, this.settings);
                } catch (particleError) {
                    console.warn('Particle system render error:', particleError);
                }
            }

            renderBackground() {
                // Create deep space gradient background
                const gradient = this.ctx.createRadialGradient(
                    this.canvas.width / 2, this.canvas.height / 2, 0,
                    this.canvas.width / 2, this.canvas.height / 2, Math.max(this.canvas.width, this.canvas.height)
                );
                gradient.addColorStop(0, '#1a1a2e');
                gradient.addColorStop(0.5, '#16213e');
                gradient.addColorStop(1, '#0f0f23');

                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Add some stars
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                for (let i = 0; i < 100; i++) {
                    const x = (i * 1234.5) % this.canvas.width;
                    const y = (i * 2345.6) % this.canvas.height;
                    const size = Math.random() * 2;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, size, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            }

            reset() {
                this.objects = [];
                this.selectedObject = null;
            }

            pause() {
                this.isRunning = false;
            }

            play() {
                this.isRunning = true;
            }

            setSpeed(speed) {
                this.speed = Math.max(0.1, Math.min(3.0, speed));
            }
        }

        // Tool System
        class ToolManager {
            constructor(simulationEngine, feedbackFunction = null) {
                this.simulation = simulationEngine;
                this.showToolFeedback = feedbackFunction || ((message) => console.log('Tool Feedback:', message));
                this.activeTool = 'sun'; // Default to sun tool for immediate interaction
                this.isDragging = false;
                this.dragStart = new Vector2D();
                this.currentMouse = new Vector2D();
                this.pendingSunMass = 2000;

                this.setupEventListeners();

                // Delay UI setup to ensure all methods are available
                setTimeout(() => {
                    this.setupUI();
                }, 0);

                // Set initial tool state after UI is set up
                try {
                    this.setActiveTool('sun');
                } catch (error) {
                    console.warn('Error setting initial tool (non-critical):', error);
                    this.activeTool = 'sun'; // Fallback
                }


            }

            setupEventListeners() {
                const canvas = this.simulation.canvas;

                canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                canvas.addEventListener('mouseup', (e) => this.handleMouseUp(e));

                // Touch events for mobile
                canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e));
                canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e));
                canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e));
            }

            setupUI() {
                try {
                    // Tool buttons
                    document.querySelectorAll('.tool-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            this.setActiveTool(btn.dataset.tool);
                        });
                    });

                    // Control buttons with error handling
                    const playPauseBtn = document.getElementById('playPauseBtn');
                    if (playPauseBtn) {
                        playPauseBtn.addEventListener('click', () => {
                            this.togglePlayPause();
                        });
                    }

                    const resetBtn = document.getElementById('resetBtn');
                    if (resetBtn) {
                        resetBtn.addEventListener('click', () => {
                            this.resetSimulation();
                        });
                    }

                    const speedSlider = document.getElementById('speedSlider');
                    if (speedSlider) {
                        speedSlider.addEventListener('input', (e) => {
                            this.simulation.setSpeed(parseFloat(e.target.value));
                        });
                    }

                    const infoToggleBtn = document.getElementById('infoToggleBtn');
                    if (infoToggleBtn) {
                        infoToggleBtn.addEventListener('click', () => {
                            this.toggleInfoPanel();
                        });
                    }

                    const settingsBtn = document.getElementById('settingsBtn');
                    if (settingsBtn) {
                        settingsBtn.addEventListener('click', () => {
                            this.toggleSettingsPanel();
                        });
                    }

                    // Mass slider
                    const massSlider = document.getElementById('massSlider');
                    const massValue = document.getElementById('massValue');
                    if (massSlider && massValue) {
                        massSlider.addEventListener('input', (e) => {
                            this.pendingSunMass = parseInt(e.target.value);
                            massValue.textContent = this.pendingSunMass;
                        });
                    }

                    const placeSunBtn = document.getElementById('placeSunBtn');
                    if (placeSunBtn) {
                        placeSunBtn.addEventListener('click', () => {
                            this.placePendingSun();
                        });
                    }

                    const cancelSunBtn = document.getElementById('cancelSunBtn');
                    if (cancelSunBtn) {
                        cancelSunBtn.addEventListener('click', () => {
                            this.cancelSunPlacement();
                        });
                    }

                    // Settings panel
                    const closeSettingsBtn = document.getElementById('closeSettingsBtn');
                    if (closeSettingsBtn) {
                        closeSettingsBtn.addEventListener('click', () => {
                            this.toggleSettingsPanel();
                        });
                    }

                    const settingsOverlay = document.getElementById('settingsOverlay');
                    if (settingsOverlay) {
                        settingsOverlay.addEventListener('click', () => {
                            this.toggleSettingsPanel();
                        });
                    }

                    // Settings controls
                    const performanceModeToggle = document.getElementById('performanceModeToggle');
                    if (performanceModeToggle) {
                        performanceModeToggle.addEventListener('change', (e) => {
                            this.setPerformanceMode(e.target.checked);
                        });
                    }

                    const trailLengthSlider = document.getElementById('trailLengthSlider');
                    const trailLengthValue = document.getElementById('trailLengthValue');
                    if (trailLengthSlider && trailLengthValue) {
                        trailLengthSlider.addEventListener('input', (e) => {
                            const value = parseInt(e.target.value);
                            trailLengthValue.textContent = value;
                            this.setTrailLength(value);
                        });
                    }

                    const maxObjectsSlider = document.getElementById('maxObjectsSlider');
                    const maxObjectsValue = document.getElementById('maxObjectsValue');
                    if (maxObjectsSlider && maxObjectsValue) {
                        maxObjectsSlider.addEventListener('input', (e) => {
                            const value = parseInt(e.target.value);
                            maxObjectsValue.textContent = value;
                            this.setMaxObjects(value);
                        });
                    }

                    // Visual settings listeners
                    const particleEffectsToggle = document.getElementById('particleEffectsToggle');
                    if (particleEffectsToggle) {
                        particleEffectsToggle.addEventListener('change', () => {
                            this.updateVisualSettings();
                        });
                    }

                    const trailEffectsToggle = document.getElementById('trailEffectsToggle');
                    if (trailEffectsToggle) {
                        trailEffectsToggle.addEventListener('change', () => {
                            this.updateVisualSettings();
                        });
                    }

                    const coronaEffectsToggle = document.getElementById('coronaEffectsToggle');
                    if (coronaEffectsToggle) {
                        coronaEffectsToggle.addEventListener('change', () => {
                            this.updateVisualSettings();
                        });
                    }

                    // Quick start guide
                    const closeGuideBtn = document.getElementById('closeGuideBtn');
                    if (closeGuideBtn) {
                        closeGuideBtn.addEventListener('click', () => {
                            // Hide the quick start guide
                            const guideElement = document.getElementById('quickStartGuide');
                            if (guideElement) {
                                guideElement.classList.add('hidden');
                                localStorage.setItem('gravitySimulatorGuideShown', 'true');
                            }
                        });
                    } else {
                        console.warn('Close guide button not found');
                    }
                } catch (error) {
                    console.error('Error setting up UI:', error);
                }
            }

            setActiveTool(toolName) {
                // Update UI
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                const toolButton = document.querySelector(`[data-tool="${toolName}"]`);
                if (toolButton) {
                    toolButton.classList.add('active');
                }

                // Update cursor with enhanced feedback
                const cursors = {
                    select: 'pointer',
                    sun: 'crosshair',
                    planet: 'grab',
                    blackhole: 'crosshair',
                    remove: 'not-allowed'
                };

                this.simulation.canvas.style.cursor = cursors[toolName] || 'default';
                this.activeTool = toolName;

                // Show tool feedback with error handling
                try {
                    const toolNames = {
                        select: 'Select Tool: Click objects to inspect them',
                        sun: 'Sun Tool: Click to place suns (hold for mass options)',
                        planet: 'Planet Tool: Drag to launch planets',
                        blackhole: 'Black Hole Tool: Click to create black holes',
                        remove: 'Remove Tool: Click objects to delete them'
                    };

                    if (this.showToolFeedback) {
                        this.showToolFeedback(toolNames[toolName] || 'Tool selected');
                    }
                } catch (error) {
                    console.warn('Error showing tool feedback (non-critical):', error);
                }

                // Hide mass slider if not placing sun
                if (toolName !== 'sun') {
                    document.getElementById('massSliderPanel').classList.remove('visible');
                }
            }

            handleMouseDown(e) {
                const rect = this.simulation.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.dragStart = new Vector2D(x, y);
                this.currentMouse = new Vector2D(x, y);
                this.isDragging = true;

                this.handleToolAction('mousedown', x, y);
            }

            handleMouseMove(e) {
                const rect = this.simulation.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                this.currentMouse = new Vector2D(x, y);

                if (this.isDragging) {
                    this.handleToolAction('mousemove', x, y);
                }
            }

            handleMouseUp(e) {
                const rect = this.simulation.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (this.isDragging) {
                    this.handleToolAction('mouseup', x, y);
                }

                this.isDragging = false;
            }

            handleTouchStart(e) {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = this.simulation.canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;

                this.handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY });
            }

            handleTouchMove(e) {
                e.preventDefault();
                const touch = e.touches[0];
                this.handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
            }

            handleTouchEnd(e) {
                e.preventDefault();
                if (e.changedTouches.length > 0) {
                    const touch = e.changedTouches[0];
                    this.handleMouseUp({ clientX: touch.clientX, clientY: touch.clientY });
                }
            }

            handleToolAction(action, x, y) {
                switch (this.activeTool) {
                    case 'select':
                        this.handleSelectTool(action, x, y);
                        break;
                    case 'sun':
                        this.handleSunTool(action, x, y);
                        break;
                    case 'planet':
                        this.handlePlanetTool(action, x, y);
                        break;
                    case 'blackhole':
                        this.handleBlackHoleTool(action, x, y);
                        break;
                    case 'remove':
                        this.handleRemoveTool(action, x, y);
                        break;
                }
            }

            handleSelectTool(action, x, y) {
                if (action === 'mousedown') {
                    // Find object at click position
                    const clickedObject = this.simulation.objects.find(obj =>
                        obj.isPointInside(x, y)
                    );

                    this.simulation.selectObject(clickedObject);
                    this.updatePropertiesPanel();
                }
            }

            handleSunTool(action, x, y) {
                if (action === 'mousedown') {
                    // Store the click position and start a timer
                    this.pendingSunPosition = new Vector2D(x, y);
                    this.sunClickTimer = setTimeout(() => {
                        // If held for 500ms, show mass slider for custom mass
                        document.getElementById('massSliderPanel').classList.add('visible');
                    }, 500);
                } else if (action === 'mouseup') {
                    // Clear the timer
                    if (this.sunClickTimer) {
                        clearTimeout(this.sunClickTimer);
                        this.sunClickTimer = null;
                    }

                    // If mass slider is not visible, it was a quick click - place default sun
                    if (!document.getElementById('massSliderPanel').classList.contains('visible')) {
                        const sun = new Sun(this.pendingSunPosition.x, this.pendingSunPosition.y, this.pendingSunMass);
                        if (this.simulation.addObject(sun)) {
                            // Success feedback
                            this.showToolFeedback('Sun created! ☀️');
                        } else {
                            this.showToolFeedback('Maximum objects reached!');
                        }
                    }
                }
            }

            handlePlanetTool(action, x, y) {
                if (action === 'mousedown') {
                    // Provide feedback when starting to drag
                    this.showToolFeedback('Drag to set planet velocity and launch! 🌎');
                } else if (action === 'mouseup' && this.isDragging) {
                    const dx = x - this.dragStart.x;
                    const dy = y - this.dragStart.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 5) {
                        const velocityScale = 0.2;
                        const planet = new Planet(
                            this.dragStart.x, this.dragStart.y,
                            dx * velocityScale, dy * velocityScale
                        );
                        if (this.simulation.addObject(planet)) {
                            this.showToolFeedback('Planet launched! 🌎');
                        } else {
                            this.showToolFeedback('Maximum objects reached!');
                        }
                    } else {
                        this.showToolFeedback('Drag farther to set planet velocity');
                    }
                }
            }

            handleBlackHoleTool(action, x, y) {
                if (action === 'mousedown') {
                    const blackHole = new BlackHole(x, y);
                    if (this.simulation.addObject(blackHole)) {
                        this.showToolFeedback('Black hole created! ⚫');
                    } else {
                        this.showToolFeedback('Maximum objects reached!');
                    }
                }
            }

            handleRemoveTool(action, x, y) {
                if (action === 'mousedown') {
                    const objectToRemove = this.simulation.objects.find(obj =>
                        obj.isPointInside(x, y)
                    );

                    if (objectToRemove) {
                        const objectType = objectToRemove.type;
                        this.simulation.removeObject(objectToRemove);
                        this.updatePropertiesPanel();
                        this.showToolFeedback(`${objectType.charAt(0).toUpperCase() + objectType.slice(1)} removed! ❌`);
                    } else {
                        this.showToolFeedback('Click on an object to remove it');
                    }
                }
            }

            placePendingSun() {
                if (this.pendingSunPosition) {
                    const sun = new Sun(
                        this.pendingSunPosition.x,
                        this.pendingSunPosition.y,
                        this.pendingSunMass
                    );
                    this.simulation.addObject(sun);
                    this.cancelSunPlacement();
                }
            }

            cancelSunPlacement() {
                document.getElementById('massSliderPanel').classList.remove('visible');
                this.pendingSunPosition = null;
            }

            togglePlayPause() {
                if (this.simulation.isRunning) {
                    this.simulation.pause();
                    document.getElementById('playPauseIcon').textContent = '▶️';
                    document.getElementById('playPauseText').textContent = 'Play';
                } else {
                    this.simulation.play();
                    document.getElementById('playPauseIcon').textContent = '⏸️';
                    document.getElementById('playPauseText').textContent = 'Pause';
                }
            }

            resetSimulation() {
                this.simulation.reset();
                this.updatePropertiesPanel();

                // Reset UI
                document.getElementById('playPauseIcon').textContent = '⏸️';
                document.getElementById('playPauseText').textContent = 'Pause';
                this.simulation.play();
            }

            toggleInfoPanel() {
                const panel = document.getElementById('infoPanel');
                panel.classList.toggle('visible');
            }

            updatePropertiesPanel() {
                try {
                    const panel = document.getElementById('propertiesPanel');
                    if (!panel) return;

                    const obj = this.simulation.selectedObject;

                    if (obj) {
                        panel.classList.add('visible');

                        const objectType = document.getElementById('objectType');
                        const objectMass = document.getElementById('objectMass');
                        const objectVelocity = document.getElementById('objectVelocity');
                        const objectForce = document.getElementById('objectForce');

                        if (objectType) {
                            objectType.textContent = obj.type.charAt(0).toUpperCase() + obj.type.slice(1);
                        }

                        if (objectMass) {
                            objectMass.textContent = obj.mass.toFixed(0) + ' units';
                        }

                        if (objectVelocity && obj.velocity) {
                            objectVelocity.textContent = obj.velocity.magnitude().toFixed(2) + ' px/s';
                        }

                        if (objectForce) {
                            // Calculate gravitational force
                            let totalForce = 0;
                            this.simulation.objects.forEach(other => {
                                if (other !== obj && (other instanceof Sun || other instanceof BlackHole)) {
                                    const force = obj.getGravitationalForce(other);
                                    if (force) {
                                        totalForce += force.magnitude();
                                    }
                                }
                            });
                            objectForce.textContent = totalForce.toFixed(2) + ' N';
                        }
                    } else {
                        panel.classList.remove('visible');
                    }
                } catch (error) {
                    console.warn('Error updating properties panel:', error);
                }
            }

            renderToolPreview() {
                if (this.activeTool === 'planet' && this.isDragging) {
                    const ctx = this.simulation.ctx;
                    ctx.strokeStyle = 'rgba(100, 200, 255, 0.7)';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(this.dragStart.x, this.dragStart.y);
                    ctx.lineTo(this.currentMouse.x, this.currentMouse.y);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw velocity indicator
                    const dx = this.currentMouse.x - this.dragStart.x;
                    const dy = this.currentMouse.y - this.dragStart.y;
                    const velocity = Math.sqrt(dx * dx + dy * dy) * 0.2;

                    ctx.fillStyle = 'rgba(100, 200, 255, 0.8)';
                    ctx.font = '12px Arial';
                    ctx.fillText(`Velocity: ${velocity.toFixed(1)}`, this.currentMouse.x + 10, this.currentMouse.y - 10);
                }
            }
        }

        // Educational Module
        class EducationalModule {
            constructor(simulationEngine) {
                this.simulation = simulationEngine;
                this.lastContext = '';
                this.updateInterval = null;

                this.startContextAnalysis();
            }

            startContextAnalysis() {
                this.updateInterval = setInterval(() => {
                    this.analyzeContext();
                }, 1000);
            }

            analyzeContext() {
                const objects = this.simulation.objects;
                const suns = objects.filter(obj => obj instanceof Sun);
                const planets = objects.filter(obj => obj instanceof Planet);
                const blackHoles = objects.filter(obj => obj instanceof BlackHole);

                let context = 'welcome';
                let title = 'Welcome to Gravity Simulator!';
                let content = 'Select a tool from the left panel to start creating your cosmic simulation. Watch as planets orbit suns, experience realistic physics, and learn about gravity!';

                if (blackHoles.length > 0) {
                    context = 'blackhole';
                    title = 'Black Holes: The Ultimate Gravity Wells';
                    content = 'Black holes have such strong gravity that nothing can escape once it crosses the event horizon (the dark boundary). Watch how they bend space and time around them!';
                } else if (this.detectStableOrbit(planets, suns)) {
                    context = 'orbit';
                    title = 'Perfect Orbital Dance!';
                    content = 'An orbit is a perfect balance between a planet\'s forward speed and the sun\'s sideways gravitational pull. The planet is constantly falling toward the sun, but always missing it!';
                } else if (suns.length > 1) {
                    context = 'multiple_suns';
                    title = 'Multiple Star System';
                    content = 'With multiple suns, planets experience complex gravitational forces from all directions. This creates intricate orbital patterns and can lead to chaotic motion!';
                } else if (planets.length > 0 && suns.length > 0) {
                    context = 'gravity';
                    title = 'Gravity in Action';
                    content = 'Gravity pulls objects together with a force that depends on their masses and distance. The closer and more massive objects are, the stronger the gravitational attraction!';
                } else if (suns.length > 0) {
                    context = 'sun_created';
                    title = 'A Star is Born!';
                    content = 'Suns are massive objects that create gravitational fields. The more massive a sun, the stronger its gravitational pull. Try launching a planet to see gravity in action!';
                }

                if (context !== this.lastContext) {
                    this.updateInfoPanel(title, content);
                    this.lastContext = context;
                }
            }

            detectStableOrbit(planets, suns) {
                return planets.some(planet => {
                    return suns.some(sun => {
                        const distance = planet.position.distance(sun.position);
                        const velocity = planet.velocity.magnitude();

                        // Simple orbital stability check
                        const orbitalVelocity = Math.sqrt(sun.mass * 0.1 / distance);
                        return Math.abs(velocity - orbitalVelocity) < orbitalVelocity * 0.3;
                    });
                });
            }

            updateInfoPanel(title, content) {
                document.getElementById('infoTitle').textContent = title;
                document.getElementById('infoContent').textContent = content;
            }

            toggleSettingsPanel() {
                const panel = document.getElementById('settingsPanel');
                const overlay = document.getElementById('settingsOverlay');

                if (panel.classList.contains('visible')) {
                    panel.classList.remove('visible');
                    overlay.classList.remove('visible');
                } else {
                    panel.classList.add('visible');
                    overlay.classList.add('visible');
                }
            }

            setPerformanceMode(enabled) {
                this.simulation.performanceMode = enabled;

                // Update other checkboxes based on performance mode
                if (enabled) {
                    document.getElementById('particleEffectsToggle').checked = false;
                    document.getElementById('trailEffectsToggle').checked = false;
                    document.getElementById('coronaEffectsToggle').checked = false;
                } else {
                    document.getElementById('particleEffectsToggle').checked = true;
                    document.getElementById('trailEffectsToggle').checked = true;
                    document.getElementById('coronaEffectsToggle').checked = true;
                }

                this.updateVisualSettings();
            }

            setTrailLength(length) {
                this.simulation.objects.forEach(obj => {
                    if (obj instanceof Planet) {
                        obj.maxTrailLength = length;
                    }
                });
            }

            setMaxObjects(max) {
                this.simulation.maxObjects = max;
            }

            updateVisualSettings() {
                const particleEffects = document.getElementById('particleEffectsToggle').checked;
                const trailEffects = document.getElementById('trailEffectsToggle').checked;
                const coronaEffects = document.getElementById('coronaEffectsToggle').checked;

                this.simulation.settings = {
                    particleEffects,
                    trailEffects,
                    coronaEffects,
                    performanceMode: this.simulation.performanceMode || false
                };
            }

            hideQuickStartGuide() {
                try {
                    const guideElement = document.getElementById('quickStartGuide');
                    if (guideElement) {
                        guideElement.classList.add('hidden');
                        localStorage.setItem('gravitySimulatorGuideShown', 'true');
                    } else {
                        console.warn('Quick start guide element not found');
                    }
                } catch (error) {
                    console.warn('Error hiding quick start guide:', error);
                }
            }

            showQuickStartGuideIfNeeded() {
                try {
                    const guideShown = localStorage.getItem('gravitySimulatorGuideShown');
                    const guideElement = document.getElementById('quickStartGuide');

                    if (!guideElement) {
                        console.warn('Quick start guide element not found');
                        return;
                    }

                    if (!guideShown) {
                        // Show guide after a short delay
                        setTimeout(() => {
                            guideElement.classList.remove('hidden');
                        }, 2000);
                    } else {
                        guideElement.classList.add('hidden');
                    }
                } catch (error) {
                    console.warn('Error showing quick start guide:', error);
                }
            }
        }

        // Main Application
        class GravitySimulatorApp {
            constructor() {
                try {
                    console.log('Initializing GravitySimulatorApp...');

                    // Initialize core components with error checking
                    this.canvas = document.getElementById('gravityCanvas');
                    if (!this.canvas) {
                        throw new Error('Canvas element not found');
                    }

                    this.simulation = new SimulationEngine(this.canvas);
                    if (!this.simulation) {
                        throw new Error('SimulationEngine failed to initialize');
                    }

                    this.toolManager = new ToolManager(this.simulation, (message) => this.showUiFeedback(message));
                    if (!this.toolManager) {
                        throw new Error('ToolManager failed to initialize');
                    }

                    this.educationalModule = new EducationalModule(this.simulation);
                    if (!this.educationalModule) {
                        throw new Error('EducationalModule failed to initialize');
                    }

                    this.lastTime = 0;
                    this.isRunning = false;

                    // Start the application
                    this.start();

                    console.log('GravitySimulatorApp initialized successfully');
                } catch (error) {
                    console.error('GravitySimulatorApp constructor error:', error);
                    throw error; // Re-throw to be caught by initializer
                }
            }

            start() {
                try {
                    console.log('Starting GravitySimulatorApp...');

                    // Validate that all components are ready
                    if (!this.simulation || !this.toolManager || !this.educationalModule) {
                        throw new Error('Not all components are initialized');
                    }

                    // Start the animation loop first
                    this.isRunning = true;
                    this.animate();

                    // Hide loading screen with delay for smooth transition
                    setTimeout(() => {
                        try {
                            const loadingScreen = document.getElementById('loadingScreen');
                            if (loadingScreen) {
                                loadingScreen.style.opacity = '0';
                                setTimeout(() => {
                                    loadingScreen.style.display = 'none';

                                    // Show quick start guide if needed (with error handling)
                                    try {
                                        if (this.toolManager && this.toolManager.showQuickStartGuideIfNeeded) {
                                            this.toolManager.showQuickStartGuideIfNeeded();
                                        }
                                    } catch (guideError) {
                                        console.warn('Quick start guide error (non-critical):', guideError);
                                    }
                                }, 500);
                            }
                        } catch (error) {
                            console.error('Error during loading screen transition:', error);
                        }
                    }, 1000);

                    console.log('GravitySimulatorApp started successfully');
                } catch (error) {
                    console.error('Error starting GravitySimulatorApp:', error);
                    throw error;
                }
            }

            animate = (currentTime) => {
                try {
                    // Only continue if app is running
                    if (!this.isRunning) {
                        return;
                    }

                    const deltaTime = (currentTime - this.lastTime) / 1000;
                    this.lastTime = currentTime;

                    // Update simulation with error handling
                    if (this.simulation && this.simulation.update) {
                        this.simulation.update(deltaTime);
                    }

                    // Render everything with error handling
                    if (this.simulation && this.simulation.render) {
                        this.simulation.render();
                    }

                    // Render tool previews with error handling
                    if (this.toolManager && this.toolManager.renderToolPreview) {
                        this.toolManager.renderToolPreview();
                    }

                    // Update properties panel if object is selected
                    if (this.simulation && this.simulation.selectedObject &&
                        this.toolManager && this.toolManager.updatePropertiesPanel) {
                        this.toolManager.updatePropertiesPanel();
                    }

                    // Continue animation loop
                    requestAnimationFrame(this.animate);
                } catch (error) {
                    console.error('Animation loop error:', error);

                    // Try to recover by restarting the animation loop after a delay
                    setTimeout(() => {
                        console.log('Attempting to restart animation loop...');
                        if (this.isRunning) {
                            requestAnimationFrame(this.animate);
                        }
                    }, 1000);
                }
            }

            stop() {
                this.isRunning = false;
                console.log('GravitySimulatorApp stopped');
            }

            // UI Feedback method - delegates to ToolManager if available
            showUiFeedback(message) {
                try {
                    // Create a temporary feedback message
                    const feedback = document.createElement('div');
                    feedback.textContent = message;
                    feedback.style.cssText = `
                        position: fixed;
                        top: 80px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: rgba(100, 200, 255, 0.9);
                        color: white;
                        padding: 8px 16px;
                        border-radius: 20px;
                        font-size: 14px;
                        font-weight: 500;
                        z-index: 1000;
                        pointer-events: none;
                        animation: feedbackFade 2s ease-out forwards;
                    `;

                    document.body.appendChild(feedback);

                    // Remove after animation
                    setTimeout(() => {
                        if (feedback.parentNode) {
                            feedback.parentNode.removeChild(feedback);
                        }
                    }, 2000);
                } catch (error) {
                    console.warn('Error showing UI feedback:', error);
                    console.log('UI Feedback:', message);
                }
            }

            // Alternative method names for compatibility
            showUIFeedback(message) {
                this.showUiFeedback(message);
            }

            showToolFeedback(message) {
                this.showUiFeedback(message);
            }
        }

        // Robust Application Initialization System
        class AppInitializer {
            constructor() {
                this.initializationTimeout = null;
                this.isInitialized = false;
                this.startTime = Date.now();
            }

            async initialize() {
                try {
                    console.log('Starting Gravity Simulator initialization...');

                    // Set up failsafe timeout (10 seconds)
                    this.initializationTimeout = setTimeout(() => {
                        if (!this.isInitialized) {
                            this.handleInitializationTimeout();
                        }
                    }, 10000);

                    // Check if critical DOM elements exist
                    await this.validateCriticalElements();

                    // Load and validate external resources
                    await this.loadExternalResources();

                    // Initialize the main application
                    await this.initializeMainApp();

                    // Mark as successfully initialized
                    this.isInitialized = true;
                    clearTimeout(this.initializationTimeout);

                    console.log(`Gravity Simulator initialized successfully in ${Date.now() - this.startTime}ms`);

                } catch (error) {
                    console.error('Initialization error:', error);
                    this.handleInitializationError(error);
                } finally {
                    // Ensure loading screen is always hidden
                    this.hideLoadingScreen();
                }
            }

            async validateCriticalElements() {
                const criticalElements = [
                    'gravityCanvas',
                    'loadingScreen',
                    'sunTool',
                    'planetTool',
                    'playPauseBtn'
                ];

                for (const elementId of criticalElements) {
                    const element = document.getElementById(elementId);
                    if (!element) {
                        throw new Error(`Critical element missing: ${elementId}`);
                    }
                }

                // Validate canvas context
                const canvas = document.getElementById('gravityCanvas');
                const ctx = canvas.getContext('2d');
                if (!ctx) {
                    throw new Error('Canvas 2D context not available');
                }

                console.log('Critical elements validated successfully');
            }

            async loadExternalResources() {
                const promises = [];

                // Check if fonts are loaded (non-critical)
                if (document.fonts) {
                    promises.push(
                        document.fonts.ready.catch(error => {
                            console.warn('Font loading failed (non-critical):', error);
                        })
                    );
                }

                // Wait for all resources with timeout
                try {
                    await Promise.race([
                        Promise.all(promises),
                        new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('Resource loading timeout')), 5000)
                        )
                    ]);
                    console.log('External resources loaded successfully');
                } catch (error) {
                    console.warn('Some external resources failed to load:', error);
                    // Continue initialization - these are non-critical
                }
            }

            async initializeMainApp() {
                // Wrap main app initialization in try-catch
                try {
                    this.app = new GravitySimulatorApp();

                    // Verify the app initialized correctly
                    if (!this.app.simulation || !this.app.toolManager) {
                        throw new Error('Main application components failed to initialize');
                    }

                    console.log('Main application initialized successfully');
                } catch (error) {
                    throw new Error(`Main application initialization failed: ${error.message}`);
                }
            }

            handleInitializationTimeout() {
                console.error('Initialization timeout after 10 seconds');
                this.showErrorMessage(
                    'Initialization Timeout',
                    'The simulation failed to start within 10 seconds. Please try refreshing the page.',
                    'timeout'
                );
                this.hideLoadingScreen();
            }

            handleInitializationError(error) {
                console.error('Initialization failed:', error);

                let errorTitle = 'Initialization Error';
                let errorMessage = 'The simulation failed to start. Please try refreshing the page.';
                let errorType = 'general';

                if (error.message.includes('Critical element missing')) {
                    errorTitle = 'Missing Components';
                    errorMessage = 'Some required interface elements are missing. Please refresh the page.';
                    errorType = 'missing-elements';
                } else if (error.message.includes('Canvas 2D context')) {
                    errorTitle = 'Graphics Not Supported';
                    errorMessage = 'Your browser does not support the required graphics features. Please try a different browser.';
                    errorType = 'graphics-unsupported';
                } else if (error.message.includes('Main application')) {
                    errorTitle = 'Application Error';
                    errorMessage = 'The main application failed to initialize. Please refresh the page or try again later.';
                    errorType = 'app-error';
                }

                this.showErrorMessage(errorTitle, errorMessage, errorType);
            }

            showErrorMessage(title, message, type) {
                // Create error overlay
                const errorOverlay = document.createElement('div');
                errorOverlay.id = 'initializationError';
                errorOverlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f0f23 100%);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    z-index: 10000;
                    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                `;

                const errorContent = document.createElement('div');
                errorContent.style.cssText = `
                    background: rgba(255, 255, 255, 0.1);
                    backdrop-filter: blur(20px);
                    border: 1px solid rgba(255, 255, 255, 0.2);
                    border-radius: 16px;
                    padding: 40px;
                    max-width: 500px;
                    text-align: center;
                    color: white;
                    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
                `;

                const errorIcon = type === 'timeout' ? '⏰' :
                    type === 'graphics-unsupported' ? '🖥️' :
                        type === 'missing-elements' ? '🧩' : '⚠️';

                errorContent.innerHTML = `
                    <div style="font-size: 48px; margin-bottom: 20px;">${errorIcon}</div>
                    <h2 style="color: #ff6b6b; margin-bottom: 16px; font-size: 24px;">${title}</h2>
                    <p style="margin-bottom: 24px; line-height: 1.6; font-size: 16px;">${message}</p>
                    <button onclick="window.location.reload()" style="
                        background: linear-gradient(45deg, #667eea, #764ba2);
                        border: none;
                        color: white;
                        padding: 12px 24px;
                        border-radius: 8px;
                        font-size: 16px;
                        cursor: pointer;
                        transition: transform 0.2s ease;
                    " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                        🔄 Refresh Page
                    </button>
                    <div style="margin-top: 20px; font-size: 12px; color: rgba(255,255,255,0.6);">
                        Error Code: ${type.toUpperCase()}_${Date.now()}
                    </div>
                `;

                errorOverlay.appendChild(errorContent);
                document.body.appendChild(errorOverlay);
            }

            hideLoadingScreen() {
                try {
                    const loadingScreen = document.getElementById('loadingScreen');
                    if (loadingScreen) {
                        loadingScreen.style.opacity = '0';
                        setTimeout(() => {
                            loadingScreen.style.display = 'none';
                        }, 300);
                    }
                } catch (error) {
                    console.error('Error hiding loading screen:', error);
                }
            }
        }

        // Initialize the application when DOM is loaded with robust error handling
        document.addEventListener('DOMContentLoaded', async () => {
            const initializer = new AppInitializer();
            await initializer.initialize();
        });
        // Emergency failsafe - ensure loading screen is never stuck
        setTimeout(() => {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen && loadingScreen.style.display !== 'none') {
                console.warn('Emergency failsafe: Force hiding loading screen after 15 seconds');
                loadingScreen.style.opacity = '0';
                setTimeout(() => {
                    loadingScreen.style.display = 'none';

                    // Show emergency message if no error overlay exists
                    if (!document.getElementById('initializationError')) {
                        const emergencyDiv = document.createElement('div');
                        emergencyDiv.style.cssText = `
                            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
                            background: rgba(255, 0, 0, 0.9); color: white; padding: 20px;
                            border-radius: 8px; text-align: center; z-index: 10001;
                            font-family: Arial, sans-serif;
                        `;
                        emergencyDiv.innerHTML = `
                            <h3>⚠️ Emergency Recovery</h3>
                            <p>The application took too long to load.</p>
                            <button onclick="window.location.reload()" style="
                                background: white; color: red; border: none; padding: 8px 16px;
                                border-radius: 4px; cursor: pointer; margin-top: 10px;
                            ">Refresh Page</button>
                        `;
                        document.body.appendChild(emergencyDiv);
                    }
                }, 300);
            }
        }, 15000);
    </script>
</body>

</html>